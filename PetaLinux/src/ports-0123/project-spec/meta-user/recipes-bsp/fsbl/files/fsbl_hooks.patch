Opsero Electronic Design Inc. 2019
Jeff Johnson
ZynqMP FSBL hooks patch
=======================
This patch modifies the ZynqMP FSBL to add code to the XFsbl_HookBeforeHandoff which is
executed before the FSBL hands over control to U-Boot. This code is necessary for 
initialization of the 96B Quad Ethernet Mezzanine and the PCS/PMA or SGMII IP cores,
so that U-Boot and Linux can make use of the Ethernet ports. The added code does the 
following:
1. Initializes GEM0 so that it's MDIO interface can be used (we need it to communicate
   with the external PHYs and the PCS/PMA or SGMII IP cores)
2. Assert reset of PCS/PMA or SGMII IP core
3. Hardware reset the 4x Ethernet PHYs and release from reset
4. Enable the 625MHz SGMII output clock of the PHY of port 3 of the 96B Quad Ethernet
   Mezzanine card (PHY address 0xF). This clock is required by the PCS/PMA or SGMII IP core
5. Release the PCS/PMA or SGMII IP core from reset
6. Disable ISOLATE bit on all PCS/PMA or SGMII IP cores, and enable autonegotiation
   on those cores for ports 0-2. Note that port 3 cannot support SGMII autonegotiation.

diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.c
index edf8a53..0d97268 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.c
@@ -55,15 +55,105 @@
 #include "xfsbl_hw.h"
 #include "xfsbl_hooks.h"
 #include "psu_init.h"
+#include "xemacps.h"
+#include "sleep.h"
+#include "xparameters.h"
 /************************** Constant Definitions *****************************/
-
-/**************************** Type Definitions *******************************/
+#define PHY_TI_IDENTIFIER					0x2000
+
+/* 96B Quad Ethernet Mezzanine PHY addresses */
+#define PORT0_SGMII_PHYADDR 2
+#define PORT0_EXT_PHY_ADDR 1
+#define PORT1_SGMII_PHYADDR 4
+#define PORT1_EXT_PHY_ADDR 3
+#define PORT2_SGMII_PHYADDR 13
+#define PORT2_EXT_PHY_ADDR 12
+#define PORT3_SGMII_RX_PHYADDR 16
+#define PORT3_SGMII_TX_PHYADDR 17
+#define PORT3_EXT_PHY_ADDR 15
+
+/* TI DP83867 PHY Registers */
+#define DP83867_R32_RGMIICTL1					0x32
+#define DP83867_R86_RGMIIDCTL					0x86
+
+#define TI_PHY_REGCR			0xD
+#define TI_PHY_ADDDR			0xE
+#define TI_PHY_PHYCTRL			0x10
+#define TI_PHY_CFGR2			0x14
+#define TI_PHY_SGMIITYPE		0xD3
+#define TI_PHY_CFGR2_SGMII_AUTONEG_EN	0x0080
+#define TI_PHY_SGMIICLK_EN		0x4000
+#define TI_PHY_REGCR_DEVAD_EN		0x001F
+#define TI_PHY_REGCR_DEVAD_DATAEN	0x4000
+#define TI_PHY_CFGR2_MASK		0x003F
+#define TI_PHY_REGCFG4			0x31
+#define TI_PHY_REGCR_DATA		0x401F
+#define TI_PHY_CFG4RESVDBIT7		0x80
+#define TI_PHY_CFG4RESVDBIT8		0x100
+#define TI_PHY_CFG4_AUTONEG_TIMER	0x60
+
+#define TI_PHY_CFG2_SPEEDOPT_10EN          0x0040
+#define TI_PHY_CFG2_SGMII_AUTONEGEN        0x0080
+#define TI_PHY_CFG2_SPEEDOPT_ENH           0x0100
+#define TI_PHY_CFG2_SPEEDOPT_CNT           0x0800
+#define TI_PHY_CFG2_SPEEDOPT_INTLOW        0x2000
+
+#define TI_PHY_CR_SGMII_EN		0x0800
+
+/* Control register masks for PCS/PMA SGMII core */
+#define IEEE_CTRL_RESET_MASK                   	0x8000
+#define IEEE_CTRL_LOOPBACK_MASK                	0x4000
+#define IEEE_CTRL_SPEED_LSB_MASK               	0x2000
+#define IEEE_CTRL_AUTONEG_MASK                  0x1000
+#define IEEE_CTRL_PWRDOWN_MASK                  0x0800
+#define IEEE_CTRL_ISOLATE_MASK                  0x0400
+#define IEEE_CTRL_RESTART_AN_MASK               0x0200
+#define IEEE_CTRL_DUPLEX_MASK               	0x0100
+#define IEEE_CTRL_COLLISION_MASK               	0x0080
+#define IEEE_CTRL_SPEED_MSB_MASK               	0x0040
+#define IEEE_CTRL_UNIDIRECTIONAL_MASK           0x0020
+
+/* Registers for PCS/PMA SGMII core */
+#define PHY_CTRL_REG	  						0
+#define PHY_STATUS_REG  						1
+#define PHY_IDENTIFIER_1_REG					2
+#define PHY_IDENTIFIER_2_REG					3
+#define PHY_DETECT_MASK 					0x1808
+#define PHY_TI_IDENTIFIER					0x2000
+#define PHY_XILINX_PCS_PMA_ID1			0x0174
+#define PHY_XILINX_PCS_PMA_ID2			0x0C00
+
+/* GPIO register offsets */
+#define GPIO_DATA_0_OFFSET		0x00000040
+#define GPIO_DATA_1_OFFSET		0x00000044
+#define GPIO_DATA_2_OFFSET		0x00000048
+#define GPIO_DATA_3_OFFSET		0x0000004C
+#define GPIO_DATA_4_OFFSET		0x00000050
+#define GPIO_DATA_5_OFFSET		0x00000054
+
+#define GPIO_DIRM_0_OFFSET		0x00000204
+#define GPIO_DIRM_1_OFFSET		0x00000244
+#define GPIO_DIRM_2_OFFSET		0x00000284
+#define GPIO_DIRM_3_OFFSET		0x000002C4
+#define GPIO_DIRM_4_OFFSET		0x00000304
+#define GPIO_DIRM_5_OFFSET		0x00000344
+
+#define GPIO_OEN_0_OFFSET		0x00000208
+#define GPIO_OEN_1_OFFSET		0x00000248
+#define GPIO_OEN_2_OFFSET		0x00000288
+#define GPIO_OEN_3_OFFSET		0x000002C8
+#define GPIO_OEN_4_OFFSET		0x00000308
+#define GPIO_OEN_5_OFFSET		0x00000348
+
+/*************** Type Definitions *******************************/
 
 /***************** Macros (Inline Functions) Definitions *********************/
 
 /************************** Function Prototypes ******************************/
 
 /************************** Variable Definitions *****************************/
+extern XEmacPs_Config XEmacPs_ConfigTable[];
+
 #ifdef XFSBL_BS
 u32 XFsbl_HookBeforeBSDownload(void )
 {
@@ -97,6 +187,121 @@ u32 XFsbl_HookBeforeHandoff(u32 EarlyHandoff)
 	/**
 	 * Add the code here
 	 */
+	XEmacPs xemac_p0;
+	XEmacPs_Config *mac_config_p0 = NULL;
+	u16 control;
+	u32 i;
+	 
+	// First initialize GEM0 so that we can use it's MDIO interface
+	u32 result = XST_SUCCESS;
+	// Obtain config of GEM0
+	for (i = 0; i < XPAR_XEMACPS_NUM_INSTANCES; i++) {
+		if (XEmacPs_ConfigTable[i].BaseAddress == (unsigned)XPAR_XEMACPS_0_BASEADDR) {
+			mac_config_p0 = &XEmacPs_ConfigTable[i];
+			break;
+		}
+	}
+
+	// Make sure that we found the GEM0 config
+	if (mac_config_p0 == NULL) {
+		XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: Could not find GEM0 config table");
+		return(Status);
+	}
+
+	// Initialize GEM0
+	result = XEmacPs_CfgInitialize(&xemac_p0, mac_config_p0,
+						mac_config_p0->BaseAddress);
+	if (result != XST_SUCCESS) {
+		XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: In %s:EmacPs Configuration Failed....\r\n", __func__);
+	}
+
+	// Set the MDIO clock divisor
+	XEmacPs_SetMdioDivisor(&xemac_p0, MDC_DIV_224);
+	
+	// Assert SGMII core reset: connected to pl_resetn0 (active low)
+	// pl_resetn0 is EMIO GPIO bank 5, bit 31, EMIO[95]
+	XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: Assert SGMII core reset\n\r");
+	XFsbl_Out32(XPAR_XGPIOPS_0_BASEADDR | GPIO_DIRM_5_OFFSET,0x80000000);	// GPIO direction = OUTPUT
+	XFsbl_Out32(XPAR_XGPIOPS_0_BASEADDR | GPIO_OEN_5_OFFSET,0x80000000);	// GPIO enable output
+	XFsbl_Out32(XPAR_XGPIOPS_0_BASEADDR | GPIO_DATA_5_OFFSET,0x00000000);
+
+	// Assert external PHY resets: connected to EMIO GPIO[0-3]
+	// EMIO[0-3] is GPIO bank 3, bits 0-3
+	XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: Hard reset external PHYs\n\r");
+	XFsbl_Out32(XPAR_XGPIOPS_0_BASEADDR | GPIO_DIRM_3_OFFSET,0x0000000F);	// GPIO direction = OUTPUT
+	XFsbl_Out32(XPAR_XGPIOPS_0_BASEADDR | GPIO_OEN_3_OFFSET,0x0000000F);	// GPIO enable output
+	XFsbl_Out32(XPAR_XGPIOPS_0_BASEADDR | GPIO_DATA_3_OFFSET,0x00000000);	// GPIO value = LOW
+	sleep(1);
+	XFsbl_Out32(XPAR_XGPIOPS_0_BASEADDR | GPIO_DATA_3_OFFSET,0x0000000F);	// GPIO value = LOW
+	sleep(1);
+
+	// Enable the 625MHz clock output on external PHY of port 3 (addr 15)
+	// This clock is required by the SGMII cores of ALL PORTS
+	XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: Enable 625MHz clock output\n\r");
+
+	// Make sure that we can read from the external PHY
+	XEmacPs_PhyRead(&xemac_p0, PORT3_EXT_PHY_ADDR, PHY_IDENTIFIER_1_REG, &control);
+	// If we don't read the correct TI identifier, then we flag the issue
+	// but we continue to release SGMII core from reset
+	if(control != PHY_TI_IDENTIFIER) {
+		XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: External PHY returned ID 0x%04X. Failed to enable SGMII clock.\r\n",control);
+	}
+	else {
+		// Enable SGMII Clock
+		XEmacPs_PhyWrite(&xemac_p0, PORT3_EXT_PHY_ADDR, TI_PHY_REGCR,
+				      TI_PHY_REGCR_DEVAD_EN);
+		XEmacPs_PhyWrite(&xemac_p0, PORT3_EXT_PHY_ADDR, TI_PHY_ADDDR,
+				      TI_PHY_SGMIITYPE);
+		XEmacPs_PhyWrite(&xemac_p0, PORT3_EXT_PHY_ADDR, TI_PHY_REGCR,
+				      TI_PHY_REGCR_DEVAD_EN | TI_PHY_REGCR_DEVAD_DATAEN);
+		XEmacPs_PhyWrite(&xemac_p0, PORT3_EXT_PHY_ADDR, TI_PHY_ADDDR,
+				      TI_PHY_SGMIICLK_EN);
+
+		// Verify the register
+		XEmacPs_PhyWrite(&xemac_p0, PORT3_EXT_PHY_ADDR, TI_PHY_REGCR,
+						  TI_PHY_REGCR_DEVAD_EN);
+		XEmacPs_PhyWrite(&xemac_p0, PORT3_EXT_PHY_ADDR, TI_PHY_ADDDR,
+						  TI_PHY_SGMIITYPE);
+		XEmacPs_PhyWrite(&xemac_p0, PORT3_EXT_PHY_ADDR, TI_PHY_REGCR,
+						  TI_PHY_REGCR_DEVAD_EN | TI_PHY_REGCR_DEVAD_DATAEN);
+		XEmacPs_PhyRead(&xemac_p0, PORT3_EXT_PHY_ADDR, TI_PHY_ADDDR, &control);
+
+		// If we failed to enable the clock, then we flag the issue and continue
+		// to release the SGMII core from reset
+		if((control & TI_PHY_SGMIICLK_EN) == 0){
+			XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: Failed to enable SGMII clock (0x%04X)\n\r",control);
+		}
+		// Otherwise we wait for the clock to stabilize before releasing
+		// the SGMII core from reset
+		else {
+			usleep(500);
+		}
+	}
+
+	// Release SGMII core reset
+	XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: Release SGMII core reset\n\r");
+	XFsbl_Out32(XPAR_XGPIOPS_0_BASEADDR | GPIO_DATA_5_OFFSET,0x80000000);
+
+	// Finally we need to disable the ISOLATE bit on all the SGMII cores
+	// because it is enabled by default
+	XFsbl_Printf(DEBUG_PRINT_ALWAYS,"96BQuadEthernet: Disable ISOLATE on all SGMII cores\n\r");
+
+	// Configure the SGMII cores (autoneg enable, full duplex, 1Gbps)
+	XEmacPs_PhyWrite(&xemac_p0, PORT0_SGMII_PHYADDR, PHY_CTRL_REG,
+			IEEE_CTRL_DUPLEX_MASK | IEEE_CTRL_SPEED_MSB_MASK |
+			IEEE_CTRL_AUTONEG_MASK);
+	XEmacPs_PhyWrite(&xemac_p0, PORT1_SGMII_PHYADDR, PHY_CTRL_REG,
+			IEEE_CTRL_DUPLEX_MASK | IEEE_CTRL_SPEED_MSB_MASK |
+			IEEE_CTRL_AUTONEG_MASK);
+	XEmacPs_PhyWrite(&xemac_p0, PORT2_SGMII_PHYADDR, PHY_CTRL_REG,
+			IEEE_CTRL_DUPLEX_MASK | IEEE_CTRL_SPEED_MSB_MASK |
+			IEEE_CTRL_AUTONEG_MASK);
+	XEmacPs_PhyWrite(&xemac_p0, PORT3_SGMII_TX_PHYADDR, PHY_CTRL_REG,
+			IEEE_CTRL_DUPLEX_MASK | IEEE_CTRL_SPEED_MSB_MASK |
+			IEEE_CTRL_UNIDIRECTIONAL_MASK);
+	XEmacPs_PhyWrite(&xemac_p0, PORT3_SGMII_RX_PHYADDR, PHY_CTRL_REG,
+			IEEE_CTRL_DUPLEX_MASK | IEEE_CTRL_SPEED_MSB_MASK |
+			IEEE_CTRL_UNIDIRECTIONAL_MASK);
 
 	return Status;
 }
